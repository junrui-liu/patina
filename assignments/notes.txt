1. Maintain **invariants** to make it easier to reason about your code and ensure correct compilation. The starter code contains some invariants you might find handy:
  1. A special register is designated to hold the result of evaluating an expression. In the starter code, we made `rax` the special register:
    ```
    let res = rax
    ```
  2. At all time, we keep track of what the value of stack pointer (`rsp`) would be _if_ the program were being executed. In the starter code, the `top` field of the `env` record reflects how many words the stack pointer have advanced so far. In other word, the invariant is
    ```
    rbp + (-1) * top * wordsize = rsp
    ```
    The `-1` factor is due to the fact that, in x86, the stack begins at a _high_ address, and it grows toward _lower_ addresses as we push things to it.
1. Determining where variables should go on the stack can be tricky. In general, there are two approaches:

  1. Do a pre-pass over the AST and pre-allocate stack space that can hold the (maximum number of) variables defined in a function.
  2. Allocate some stack space every time you see a new variable. This just requires a single pass over the AST (i.e., the `compile` function).

  Most compilers adopt the first approach, while in this assignment the second approach is probably easier to implement.

2. Be very careful how you maintain the stack if you’re doing push’ and pop’s. As a general rule of thumb, make sure every push is matched by a later pop.

2. To debug the x86 assembly generated by your compiler, we recommend using `gdb` to step through the instructions. Alternatively, you can walk through the assembly compiled from a minimal program on paper.