<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Patina Programming Language</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="overview/overview.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="overview/integer.html"><strong aria-hidden="true">1.1.</strong> Integer Expressions</a></li><li class="chapter-item expanded "><a href="overview/boolean.html"><strong aria-hidden="true">1.2.</strong> Boolean Expressions</a></li><li class="chapter-item expanded "><a href="overview/unit.html"><strong aria-hidden="true">1.3.</strong> Unit Expressions</a></li><li class="chapter-item expanded "><a href="overview/arrays.html"><strong aria-hidden="true">1.4.</strong> Arrays</a></li><li class="chapter-item expanded "><a href="overview/functions.html"><strong aria-hidden="true">1.5.</strong> Functions</a></li></ol></li><li class="chapter-item expanded "><a href="ref.html"><strong aria-hidden="true">2.</strong> Reference Manual</a></li><li class="chapter-item expanded "><a href="setup/setup.html"><strong aria-hidden="true">3.</strong> Setting up OCaml</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="setup/opam.html"><strong aria-hidden="true">3.1.</strong> Installing opam</a></li><li class="chapter-item expanded "><a href="setup/ocaml.html"><strong aria-hidden="true">3.2.</strong> Installing OCaml</a></li><li class="chapter-item expanded "><a href="setup/run.html"><strong aria-hidden="true">3.3.</strong> Interacting with OCaml Code</a></li></ol></li><li class="chapter-item expanded "><a href="assignments/assignments.html"><strong aria-hidden="true">4.</strong> Programming Assignments</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="assignments/as1.html"><strong aria-hidden="true">4.1.</strong> Assignment 1: OCaml</a></li><li class="chapter-item expanded "><a href="assignments/as2.html"><strong aria-hidden="true">4.2.</strong> Assignment 2: Lexing and Parsing</a></li><li class="chapter-item expanded "><a href="assignments/as3.html"><strong aria-hidden="true">4.3.</strong> Assignment 3: Type Checking</a></li><li class="chapter-item expanded "><a href="assignments/as4.html"><strong aria-hidden="true">4.4.</strong> Assignment 4: Code Generation</a></li><li class="chapter-item expanded "><a href="assignments/as5.html"><strong aria-hidden="true">4.5.</strong> Assignment 5: Optimizations</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Patina Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><a href="./overview/overview.html">Chapter 1</a> introduces you to the Patina programming language, for which you will be writing your own compiler!</p>
<p>Patina is an imperative language whose syntax is very similar to the <a href="https://www.rust-lang.org/">Rust programming language</a>. We designed it so that it is big enough to let you write many interesting programs (e.g. your favorite sorting algorithm), but small enough that a compiler for Patina can be implemented in a quarter-long course.</p>
<p><a href="./ref.html">Chapter 2</a> describes the language more formally, specifying the syntax, dynamic semantics, and static semantics of each language construct.</p>
<p><a href="./setup/setup.html">Chapter 3</a> walks you through setting up OCaml on your computer, which you will need for the programming assignments, described in <a href="./assignments/assignments.html">Chapter 4</a>. The assignments build on each other, and in the end you will have a complete, optimizing compiler that can translate any valid Patina program down to x86 assembly, which your computer will be able to execute.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<blockquote>
<p>This chapter gives an informal overview of the Patina language. More precise specifications can be found in the next chapter.</p>
</blockquote>
<p>A Patina program consists of a list of function definitions, one of is a function called <code>main</code> that acts as the entry point of the program:</p>
<pre><code class="language-rust no_run noplayground">fn my_function(&lt;arg_name&gt;: &lt;arg_type&gt;) -&gt; &lt;return_type&gt; {
  ... // body of my_function
}

... // more function definitions

fn main() -&gt; unit {
  ... // body of main
}
</code></pre>
<p>Patina is an expression-oriented language. This means that</p>
<ol>
<li>Statements (like those in Java or C) don't have a distinguished status in Patina. Instead, everything is an expression; statements are just expressions that don't produce values, and they can be used anywhere an expression can be used.</li>
<li>The body of each function is simply an expression (i.e. there are no explicit <code>return</code> statements like in Java or C). Executing a function simply means evaluating the expression that is the body of the function.</li>
</ol>
<p>Let's see what kinds of expressions we can write in Patina.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="integer-expressions"><a class="header" href="#integer-expressions">Integer Expressions</a></h2>
<p>The most basic expressions in Patina are integer constants, and they can be composed into larger expressions using binary arithmetic operators <code>+</code>, <code>-</code>, <code>*</code> and <code>/</code>. For example,</p>
<pre><code class="language-rust no_run noplayground">(1 + 2) / 3 * 4 
</code></pre>
<p>is a valid Patina expression with value <code>4</code>. Negative integers are written in the usual way, e.g. <code>-2</code>.</p>
<p>Integer expressions have type <code>int</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="boolean-expressions"><a class="header" href="#boolean-expressions">Boolean Expressions</a></h2>
<p>The most basic boolean expressions are boolean constants <code>true</code> and <code>false</code>. More complex boolean expressions can be constructed in two ways:</p>
<ol>
<li>by comparing two integer expressions using the <em>comparison operators</em>: <code>==</code> (equal), <code>!=</code> (not equal), <code>&lt;</code> (less than), <code>&gt;</code> (greater than), <code>&lt;=</code> (less than or equal to) and <code>&gt;=</code> (greater than or equal to),</li>
<li>by composing smaller boolean expressions using the <em>boolean operators</em>: <code>!</code> (not), <code>&amp;&amp;</code> (and), <code>||</code> (or).</li>
</ol>
<p>For instance, the following expression evaluates to <code>true</code>:</p>
<pre><code class="language-rust no_run noplayground">(3 &gt; 4 &amp;&amp; (1 == 1)) || !false
</code></pre>
<p>Boolean expressions have type <code>bool</code>.</p>
<h3 id="branching"><a class="header" href="#branching">Branching</a></h3>
<p>Patina supports <em>if-then-else expressions</em>, which evaluates to the then-expression when the condition expression evaluates to <code>true</code> or the else-expression otherwise. For example, the expression</p>
<pre><code class="language-rust no_run noplayground">if 0 &lt;= 1 then {
  2 + 3
} else {
  3 * 4
}
</code></pre>
<p>evaluates to <code>5</code>.<sup class="footnote-reference"><a href="#1">1</a></sup></p>
<p>Note that it is possible to simulate &quot;else if&quot; clauses by nesting multiple if-then-else. For example,</p>
<pre><code class="language-rust no_run noplayground">if 0 == 1 then {
  3
} else {
  if 0 == 2 then {
    5
  } else {
    7
  }
}
</code></pre>
<p>evaluates to <code>7</code>.</p>
<p>You may have noticed the extra pair of curly braces that enclose the <code>then</code> and the <code>else</code> branch. They are not just there for readability; in fact, <code>{ ... }</code> is another kind of expression in Patina, called <em>sequence expressions</em>. You will learn more about them in the next section.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>For those of you familiar with C++ (or Java), Patina's if-then-else expressions correspond to C++'s conditional expressions. For example, the if-then-else expression here would translate to <code>0&lt;=1 ? (2+3) : (3*4)</code> in C++. Importantly, Patina's if-then-else expressions are different from C++'s if-<em>statements</em>. Statements don't produce values, but expressions do.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h2 id="unit-expressions"><a class="header" href="#unit-expressions">Unit expressions</a></h2>
<p>Patina expressions don't always need to evaluate to an <code>int</code> or <code>bool</code> value. For some expressions, their only purpose is to have some side effect upon the execution of the program. Printing something to standard output is among one of those scenarios. In Patina, evaluating the expression</p>
<pre><code class="language-rust no_run noplayground">print_int(8)
</code></pre>
<p>has the effect of printing the integer <code>8</code> to the standard output, but the expression itself doesn't evaluate to any integer value (i.e., it is meaningless to write <code>print_int(8) + 2</code>).</p>
<p>In Patina, expressions like this have a special type called <code>unit</code>. An expression of <code>unit</code> type evaluates to a special value called the <em>unit value</em>, written as <code>()</code>.  Note that the unit value <code>()</code> is the only value that inhabits type <code>unit</code>. Compare it with type <code>int</code>, which harbors many values, such as <code>0</code>, <code>-3</code>, <code>42</code>, <code>1024</code>, ...</p>
<h3 id="sequencing"><a class="header" href="#sequencing">Sequencing</a></h3>
<p>It is often useful to string together multiple unit expressions with side effects, and evaluate them one by one. Say we would like to print two integers. In Patina, we can express this using a <em>sequence expression</em>:</p>
<pre><code class="language-rust no_run noplayground">{
  print_int(8);
  print_int(9)
}
</code></pre>
<p>This should be understood as a single overall expression <code>e</code> written as <code>{ e1 ; e2 }</code>. The expression <code>e</code> contains two sub-expressions, namely, <code>print_int(8)</code> as <code>e1</code> and <code>print_int(9)</code> as <code>e2</code>.</p>
<p>To evaluate a sequence expression <code>{ e1; e2; ...; en }</code>, we evaluate each <code>ei</code> sequentially, discarding the values of all expressions except for the last expression <code>en</code>.
The value of <code>en</code> will become the value of the overall sequence expression.</p>
<p>So in the previous example, the value of the overall sequence expression is the value of <code>print_int(9)</code>, which is <code>()</code>, the unit value. The value of <code>print_int(8)</code> is suppressed.<sup class="footnote-reference"><a href="#1">1</a></sup></p>
<p>A sequence has to have at least one expression, but it may very well have just a single expression, as you have encountered in a previous if-then-else expression:</p>
<pre><code class="language-rust no_run noplayground">if 0 &lt;= 1 then {
  2 + 3
} else {
  3 * 4
}
</code></pre>
<p>Here, the <code>then</code> branch contains the sequence <code>{ 2 + 3 }</code> consisting of a single expression <code>2 + 3</code> (and similarly with the <code>else</code> branch).</p>
<p>Sequences also appear as while expressions's body and functions' body, both of which we will introduce shortly.</p>
<h3 id="variable-declaration"><a class="header" href="#variable-declaration">Variable Declaration</a></h3>
<p>Sequence expressions not only are useful for specifying sequential computation with side effects, but they also delineate how long variables declared inside them should live. Let's first see how variables are declared in Patina.</p>
<p>Variable declaration is another kind of side effect in addition to printing to standard output. In Patina, variables are created using <em>let-expressions</em>:</p>
<pre><code class="language-rust no_run noplayground">let x: T = e
</code></pre>
<p>This expression will create a new variable <code>x</code> of type <code>T</code>, which is initialized with the value of expression <code>e</code>. Then, <code>x</code> becomes available (&quot;in-scope&quot;) in subsequent expressions <em>within the same sequence</em>.</p>
<p>For example,</p>
<pre><code class="language-rust no_run noplayground">{
  let x: int = 5;
  let y: int = x + 1;
  print_int(x * y)
}
</code></pre>
<p>will print out <code>30</code>, but</p>
<pre><code class="language-rust no_run noplayground">{
  {
    let x: int = 5;
    let y: int = x + 1
  };
  print_int(x * y)
}
</code></pre>
<p>will result in a compile-time error due to the last line: variables <code>x</code> and <code>y</code> are only available inside the inner sequence, and are not available in the outer sequence.</p>
<p>Let-expressions themselves have type <code>unit</code>.</p>
<h3 id="variable-assignments"><a class="header" href="#variable-assignments">Variable Assignments</a></h3>
<p>In addition to reading the value of an variable, you might also want to mutate it. Patina has <em>assignment expressions</em> for this purpose. For example,</p>
<pre><code class="language-rust no_run noplayground">{
  let x: int = -1;
  x = x + 2;
  print_int(x)
}
</code></pre>
<p>initializes a new integer variable <code>x</code> with value <code>-1</code>, increments the value of <code>x</code> by <code>2</code>, and prints <code>1</code> to the screen.</p>
<h3 id="while-expressions"><a class="header" href="#while-expressions">While Expressions</a></h3>
<p>Patina's <em>while expressions</em> are very similar to the while loops in other imperative languages like C or Java. A while expression has a <em>condition</em> and a <em>body sequence</em>:</p>
<pre><code class="language-rust no_run noplayground">while cond {
  e1;
  e2;
  ..;
  en
}
</code></pre>
<p>To evaluate a while expression, we first evaluate its condition:</p>
<ul>
<li>If it is <code>true</code>, then we evaluate the body sequence repeatedly until the condition evaluates to <code>false</code>.</li>
<li>Otherwise, the body sequence will not be evaluated.</li>
</ul>
<p>For example,</p>
<pre><code class="language-rust no_run noplayground">{
  let i: int = 0;
  while i &lt; 3 {
    i = i + 1
  };
  print_int(i)
}
</code></pre>
<p>will print <code>3</code> to the standard output.</p>
<p>The condition should have type <code>bool</code>, and the body have type <code>unit</code>. The overall while expression will have type <code>unit</code>.</p>
<p>For simplicity, Patina has no <code>break</code> or <code>continue</code> constructs.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>For those of you familiar with Java or C, the semicolon has a different meaning here. In Java or C, a semicolon signals the end of a simple statement. In Patina, a semicolon is part of the syntax for sequence expressions, so they must appear together with a surrounding pair of curly braces. Moreover, a semicolon is always sandwiched between two expressions, and it means that &quot;we don't care the value of the first expression, but please evaluate it before you evaluate the expression after the semicolon.&quot;</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h2 id="arrays"><a class="header" href="#arrays">Arrays</a></h2>
<p>Patina supports dynamically allocated, zero-indexed arrays of integers.</p>
<h3 id="array-allocation"><a class="header" href="#array-allocation">Array Allocation</a></h3>
<p>We can create an array by calling the built-in function <code>alloc(..)</code> with a desired length. All elements will be initialized to <code>0</code>. For example,</p>
<pre><code class="language-rust no_run noplayground">{
  let len: int = 3;
  let xs: [int] = alloc(len)
}
</code></pre>
<p>creates an array of length <code>3</code> and binds it to variable <code>xs</code>.</p>
<h3 id="reading-from-an-array"><a class="header" href="#reading-from-an-array">Reading from an Array</a></h3>
<p>Array elements can be accessed using <em>array-access expressions</em>, written as</p>
<pre><code class="language-rust no_run noplayground">xs[i]
</code></pre>
<p>where <code>xs</code> is an array, and <code>i</code> is an integer expression.</p>
<h3 id="writing-to-an-array-element"><a class="header" href="#writing-to-an-array-element">Writing to an Array Element</a></h3>
<p>When an array access appears on the left-hand side of an assignment, the selected array element can be mutated, just like how the value of a variable is mutated. For example,</p>
<pre><code class="language-rust no_run noplayground">{
  let singleton: [int] = alloc(1);
  singleton[0] = 100
}
</code></pre>
<p>changes the 0-th element of <code>singleton</code> from the default value of <code>0</code> to <code>100</code>.</p>
<h3 id="aliasing"><a class="header" href="#aliasing">Aliasing</a></h3>
<p>Aliasing is permitted in Patina. Two array variables can simultaneously refer to the same array object:</p>
<pre><code class="language-rust no_run noplayground">{
  let xs: [int] = alloc(1);
  let ys: [int] = xs; // ys refers to the same array as xs
  ...
}
</code></pre>
<p>Arrays are passed by reference. So <code>[int]</code> is like a pointer to integer (<code>int *</code>) in C++. In the following example, both <code>reverse_1</code> and <code>reverse_2</code> reverses the input array. However, <code>reverse_1</code> modifies the input array <em>in place</em>, while <code>reverse_2</code> returns a <em>new</em> array that's the reverse of the input array.</p>
<pre><code class="language-rust no_run noplayground">fn reverse_1(xs: [int], len: int) -&gt; unit {
  let mid: int = len / 2;
  let i: int = 0;
  while i &lt; mid {
    xs[i] = xs[len - i - 1];
    i = i + 1
  }
}

fn reverse_2(xs: [int], len: int) -&gt; [int] {
  let ys: [int] = alloc(len);
  let i: int = 0;
  while i &lt; len {
    ys[i] = xs[len - i - 1];
    i = i + 1
  };
  ys
}
</code></pre>
<h3 id="extent"><a class="header" href="#extent">Extent</a></h3>
<p>Because you're not required to implement a garbage collector for your compiler, arrays will have infinite extent. In other words, an array cannot be destroyed once it has been allocated.</p>
<p>In the following example, even after the function <code>f</code> has returned, the array referred to by <code>xs</code> inside the body of <code>f</code> continues to exist in heap memory. But we can't access the array again, because its only name <code>xs</code> is no longer available outside the function body:</p>
<pre><code class="language-rust no_run noplayground">fn f() -&gt; unit {
  let xs: [int] = alloc(1); // xs refers to an array in heap memory
  ()
}

fn main() -&gt; unit {
  f();
  ... // can't refer to that array anymore, since xs is out-of-scope
}
</code></pre>
<p>Once we've created an array, unless we always remember its name (or one of its names), the array would become an unnameable identity forever lost in heap memory. This is what's called a <a href="https://en.wikipedia.org/wiki/Memory_leak">memory leak</a>, which plagues programs written in unmanaged languages like C and C++. You will learn about solutions to this problem in the second half of the course, although you won't be required to implement them <sup class="footnote-reference"><a href="#1">1</a></sup>.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Also, learn how Rust prevents resource leaks using a <a href="https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html">completely different approach</a>. It's super cool!</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<p>In Patina, functions are the only creatures that are <em>not</em> expressions. They are declared at the top level, along with the mandatory <code>main</code> function.</p>
<p>By convention, <code>main</code> doesn't take in any argument, and always has return type <code>unit</code>:</p>
<pre><code class="language-rust no_run noplayground">fn main() -&gt; unit
</code></pre>
<p>Other functions can have any return type (<code>unit</code>, <code>bool</code>, <code>int</code>, or <code>[int]</code>), and their arguments also need to be annotated with types. The body of each function is a <em>sequence expression</em> whose type must match the declared return type.</p>
<h3 id="recursion"><a class="header" href="#recursion">Recursion</a></h3>
<p>Functions can be recursive. This program will print out <code>55</code>, the tenth fibonacci number (indexing from zero).</p>
<pre><code class="language-rust no_run noplayground">fn fibonacci(x: int) -&gt; int {
  if x == 0 || x == 1 then {
    x
  } else {
    fibonacci(x-1) + fibonacci(x-2)
  }
}

fn main() -&gt; unit {
  print_int(fibonacci(10))
}
</code></pre>
<p>You can also define mutually recursive functions:</p>
<pre><code class="language-rust no_run noplayground">fn even(x: int) -&gt; bool {
  x == 0 || odd(x - 1)
}

fn odd(x: int) -&gt; bool {
  x == 1 || even(x - 1)
}

fn main() -&gt; unit {
  print_bool(odd(3))
}
</code></pre>
<p>This program will print out <code>true</code>.</p>
<h3 id="built-in-functions"><a class="header" href="#built-in-functions">Built-in Functions</a></h3>
<p>Patina also provides the following built-in functions, which can be called freely in Patina programs:</p>
<pre><code class="language-rust no_run noplayground">// print a boolean to stdout
fn print_bool(x: bool) -&gt; unit

// print an integer to stdout
fn print_int(x: int) -&gt; unit

// print an array of integers to stdout
fn print_arr(xs: [int], length: int) -&gt; unit
 
// print the newline character '\n' to stdout
fn print_ln() -&gt; unit

// allocate a new, zero-initialized array of specified length
fn alloc(length: int) -&gt; [int] 
</code></pre>
<p>For example, the following program</p>
<pre><code class="language-rust no_run noplayground">fn main() -&gt; unit {
  print_bool(!true);
  print_ln();

  print_int(0);
  print_int(1);
  print_ln();
  
  let xs: [int] = alloc(3);
  xs[0] = 3;
  xs[1] = 2;
  xs[2] = 1;
  print_arr(xs, 3);
  print_ln()
}
</code></pre>
<p>will print out</p>
<pre><code class="language-rust no_run noplayground">false
01
3 2 1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reference-manual"><a class="header" href="#reference-manual">Reference Manual</a></h1>
<!-- TODO: For each language construct, describe its
- syntax
- dynamic semantics
- static semantics -->
<h2 id="concrete-syntax"><a class="header" href="#concrete-syntax">Concrete Syntax</a></h2>
<pre><code>Program   ::= Function+
Function+ ::= a non-empty list of &quot;Function&quot;
Function  ::= fn ID ( Param* ) -&gt; Type Sequence
Param*    ::= a list of &quot;ID : Type&quot; separated by &quot;,&quot;
Type      ::= unit | bool | int | [int]
Sequence  ::= { Expr+ }
Expr+     ::= a non-empty list of &quot;Expr&quot; separated by &quot;;&quot;
Expr      ::= ()
           | true | false 
           | NON_NEG_INT
           | ID
           | ( Expr )
           | - Expr
           | ! Expr
           | Expr ⊕ Expr      ⊕ ∈ { +, -, *, /, &amp;&amp;, ||, ==, !=, &gt;=, &gt;, &lt;=, &lt; }
           | Sequence
           | if Expr then Sequence else Sequence
           | let ID : Type = Expr
           | while Expr Sequence
           | ID [ Expr ]
           | ID = Expr
           | ID [ Expr ] = Expr
           | ID ( Expr* )
Expr*     ::= a list of &quot;Expr&quot; separated by &quot;,&quot;

ID          = a letter or underscore, followed by any number of letters, numbers, or underscores
</code></pre>
<h3 id="precedence-and-associativity"><a class="header" href="#precedence-and-associativity">Precedence and Associativity</a></h3>
<p>Unary operators have the highest precedence, followed by the arithmetic operators, integer relations, and logical operators, with their usual precedence. That is, multiplication and division have higher precedence than addition and subtraction, and logical conjunction has higher precedence over disjunction.</p>
<p>Operators associate to the left. Relations are non-associative.</p>
<h2 id="typing-rules"><a class="header" href="#typing-rules">Typing Rules</a></h2>
<h3 id="changelog"><a class="header" href="#changelog">Changelog</a></h3>
<p>None</p>
<p>Please view the typing rules <a href="https://github.com/fredfeng/CS160/blob/main/assignments/as3/types/type.pdf">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setting-up-ocaml"><a class="header" href="#setting-up-ocaml">Setting up OCaml</a></h1>
<p>This guide covers how to set up OCaml on your computer.</p>
<ol>
<li>
<p><a href="setup/./opam.html">Installing <code>opam</code></a> walks you through how to install <code>opam</code>, the package manager for OCaml. You can think of this as a gateway to all official and third-party OCaml packages. You will need to go through <code>opam</code> to install anything OCaml-related.</p>
</li>
<li>
<p>Once you have <code>opam</code>, <a href="setup/./ocaml.html">Installing OCaml</a> walks you through setting up the core tools necessary to run any OCaml program.</p>
</li>
<li>
<p><a href="setup/./run.html">Interacting with OCaml code</a> introduces common ways of interacting with OCaml code.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h2 id="installing-opam"><a class="header" href="#installing-opam">Installing <code>opam</code></a></h2>
<blockquote>
<p>Adapted from <a href="https://github.com/fredfeng/CS162/blob/master/sections/section1/install_ocaml.md">this guide</a> written by Bryan Tan.</p>
</blockquote>
<p><code>opam</code> is a package manager for OCaml. You will later use it to install OCaml compilers, interpreters, and other third-party libraries needed for this course.</p>
<h2 id="installing-on-csil-machines"><a class="header" href="#installing-on-csil-machines">Installing on CSIL Machines</a></h2>
<p><code>opam</code> is a little trickier to set up on CSIL. If you don't have an account yet, create one using this <a href="https://accounts.engr.ucsb.edu/create">link</a>.</p>
<blockquote>
<p>Note: If you previously had an unsuccessful installation of <code>opam</code>, please run <code>rm -rf ~/.opam</code> to clean up partial installation before retrying the steps below.</p>
</blockquote>
<p>Log onto a CSIL machine (you can do it <a href="https://ucsb-engr.atlassian.net/wiki/spaces/EPK/pages/575373494/Can+I+remote+log+in+to+CSIL+Linux+from+home">remotely</a>). Once you're logged in, fire up a terminal if you don't have one open, and type the following command to download the <code>opam</code> binary:</p>
<pre><code class="language-bash">curl -LR 'https://github.com/ocaml/opam/releases/download/2.1.0/opam-2.1.0-x86_64-linux' -o opam
</code></pre>
<p>Then make sure the downloaded binary is executable, and move it to <code>~/bin/opam</code>:</p>
<pre><code class="language-bash">chmod +x opam
mkdir -p ~/bin/
mv opam ~/bin/opam
</code></pre>
<p>Check to make sure it's on <code>PATH</code>:</p>
<pre><code>[junrui@csil-08 ~]$ opam --version
2.1.0
</code></pre>
<p>Lastly, run <code>opam init</code>. <strong>This will take 20-40 minutes</strong> because it has to download a bunch of stuff. It will prompt you once or twice afterwards; you can safely respond with Y to make your life more convenient.</p>
<h2 id="installing-for-non-csil-linux"><a class="header" href="#installing-for-non-csil-linux">Installing for <strong>Non-CSIL</strong> Linux</a></h2>
<p>Follow the steps <a href="https://opam.ocaml.org/doc/Install.html#Binary-distribution">here</a>, under the &quot;Binary distribution&quot; section header.</p>
<h2 id="installing-for-macos"><a class="header" href="#installing-for-macos">Installing for macOS</a></h2>
<p>If you have <a href="https://brew.sh/">homebrew</a>, just run</p>
<pre><code>brew install gpatch
brew install opam
</code></pre>
<p>Otherwise, follow the same steps in &quot;Installing for Linux&quot; section.</p>
<h2 id="installing-for-windows"><a class="header" href="#installing-for-windows">Installing for Windows</a></h2>
<p>Windows users are recommended to use CSIL instead, since OCaml doesn't work too well on Windows.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="installing-ocaml"><a class="header" href="#installing-ocaml">Installing OCaml</a></h2>
<p>Once you have <code>opam</code>, you can create a &quot;switch&quot; so that anything you installed for this course won't contaminate the global environment.</p>
<p>Inside your terminal, run</p>
<pre><code class="language-bash">opam switch create cs160 ocaml-base-compiler.4.13.0
eval $(opam env)
</code></pre>
<p>This will create a new switch called <code>cs160</code>. It will also compile the tools necessary to run OCaml programs, including a compiler (<code>ocamlc</code>) and an interpreter (<code>ocaml</code>).</p>
<p>Once the switch is created, you can play with the interpreter by running <code>ocaml</code> in your terminal.</p>
<p>But we recommend using <code>utop</code> as an alternative. To install it, run</p>
<pre><code class="language-bash">opam install utop
</code></pre>
<p><code>opam</code> will install any additional dependencies required by <code>utop</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="interacting-with-ocaml-code"><a class="header" href="#interacting-with-ocaml-code">Interacting with OCaml Code</a></h2>
<h3 id="interacting-without-source-files"><a class="header" href="#interacting-without-source-files">Interacting without Source Files</a></h3>
<p>Simply run <code>utop</code> on your terminal. You can enter OCaml expressions and let bindings.</p>
<h3 id="running-an-ocaml-program"><a class="header" href="#running-an-ocaml-program">Running an OCaml Program</a></h3>
<p>Open your favorite code editor, and create a file called <code>hello.ml</code> that contains the following lines:</p>
<pre><code class="language-ocaml">let s = &quot;hello&quot; 
let _ = print_endline s
</code></pre>
<p>Run <code>utop hello.ml</code> to let <code>utop</code> interpret your program from start to finish. You will see &quot;hello&quot; printed on your terminal.</p>
<p>Alternatively, you can run <code>utop</code> with no arguments, and load your program dynamically with</p>
<pre><code>#use &quot;hello.ml&quot;;;
</code></pre>
<p>You will also see &quot;hello&quot; printed on your screen, but this time <code>utop</code> won't exit. So you can continue to use the interpreter, with everything defined in <code>hello.ml</code> now available for use. For instance, the variable <code>s</code> containing the string <code>&quot;hello&quot;</code> is still available, so you can continue to do</p>
<pre><code>print_endline s;;
</code></pre>
<h3 id="building-an-ocaml-project-with-multiple-files"><a class="header" href="#building-an-ocaml-project-with-multiple-files">Building an OCaml Project with Multiple Files</a></h3>
<p>You will need a build system, like <a href="https://github.com/ocaml/dune">dune</a>, to manage OCaml programs that spread over more than one file. But for the course assignments we will set up everything for you. So no need to worry about this scenario!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="programming-assignments"><a class="header" href="#programming-assignments">Programming Assignments</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cs160-assignment-1-ocaml"><a class="header" href="#cs160-assignment-1-ocaml">CS160 Assignment 1: OCaml</a></h1>
<p><strong>Assignment due: Monday, October 18 11:59PM</strong></p>
<h2 id="changelog-1"><a class="header" href="#changelog-1">Changelog</a></h2>
<ul>
<li>Problem 3:
<ul>
<li>For <code>Let (x, e)</code>, further <code>Let</code>-bindings created inside <code>e</code> will not be inherited.</li>
</ul>
</li>
<li>Problem 4:
<ul>
<li>For <code>While</code>'s condition, treat the zero value as false, and non-zero values as true.</li>
</ul>
</li>
<li>Problem 2:
<ul>
<li>You don't need to worry about division by zero.</li>
<li><code>Div</code> is to be interpreted as integer division.</li>
</ul>
</li>
</ul>
<h2 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h2>
<p>In this assignment, you will get some practice with recursion and pattern matching by building a sequence of interpreters for increasingly large subsets of the Patina programming language.</p>
<p>There are 3 main parts to the assignment (Problems 1-3), as well as a bonus problem (Problem 4). For each problem, we'll provide a file containing some starter code. They can be found in the <a href="https://github.com/fredfeng/CS160/tree/main/assignments/as1">CS160 GitHub repo</a>:</p>
<ul>
<li><code>assoc.ml</code> (Problem 1)</li>
<li><code>patina_arith.ml</code> (Problem 2)</li>
<li><code>patina_let.ml</code> (Problem 3)</li>
<li><code>patina_ref.ml</code> (Problem 4)</li>
</ul>
<p>You will fill in the missing parts of the code that are marked with <code>(* your code here *)</code>.</p>
<p>If you're stuck for more than 15 minutes on a problem, try to ask a general question on slack, or if you can't, direct message a TA.</p>
<p>Respect academic integrity; no sharing solutions, code or otherwise. You may use the internet, but not for finding solutions to these particular problems.</p>
<h2 id="submission-and-grading"><a class="header" href="#submission-and-grading">Submission and Grading</a></h2>
<p>Please submit the following files to <a href="https://www.gradescope.com/courses/322641/assignments">Gradescope</a>:</p>
<ul>
<li><code>assoc.ml</code></li>
<li><code>patina_arith.ml</code></li>
<li><code>patina_let.ml</code></li>
<li><code>patina_ref.ml</code></li>
</ul>
<p>You are free to leave the assertions in your files uncommented, as long as they don't break your code.</p>
<p>Each test case is worth 1 point.</p>
<p>The test cases for the bonus problem will be available soon.</p>
<h2 id="problem-1-"><a class="header" href="#problem-1-">Problem 1 [★]</a></h2>
<blockquote>
<p>Goal of this exercise: Practice tuples, options, and recursion over lists.</p>
</blockquote>
<p>In this problem, you will implement the <a href="https://en.wikipedia.org/wiki/Association_list">association list</a> data structure, which you may need for a later problem.</p>
<p>Association lists are the simplest kind of lookup tables. In OCaml, they are <code>('k * 'v) list</code> that map keys of type <code>'k</code> to values of type <code>'v</code>. To insert a key-value pair into an association list, we simply insert the key-value pair to the beginning of the list:</p>
<pre><code class="language-ocaml">let insert (k: 'k) (v: 'v) (al: ('k * 'v) list) : ('k * 'v) list =
  (k,v) :: al
</code></pre>
<p>That is, <code>insert</code> takes a key and a value, as well as a list of keys and values, and inserts the key-value pair to the beginning of the list.</p>
<p>Note that the key's and value's types are not concrete, because the <code>insert</code> function is designed to work over any two key value types (an example of <em>polymorphism</em>). However, the list that the key-value pair is being inserted into must be a list of the correct type.</p>
<p>You will implement the complementary <code>lookup_opt</code> function. It looks like</p>
<pre><code class="language-ocaml">let rec lookup_opt (k: 'k) (al: ('k * 'v) list) : 'v option =
  match al with
  | _ -&gt; failwith &quot;Not yet implemented&quot; (* your code here *) 
</code></pre>
<p>To query the value associated with a key <code>k</code> in the list, we find the frontmost pair whose key matches <code>k</code>, and we return the associated value. 
However, our query <code>k</code> might not be in our list. That's why the return type is <code>'v option</code>, instead of <code>'v</code>.</p>
<p>In the example below, we insert</p>
<ul>
<li><code>(&quot;x&quot;, 1)</code>,</li>
<li><code>(&quot;y&quot;, 2)</code>,</li>
<li><code>(&quot;x&quot;, 3)</code></li>
</ul>
<p>to the list <code>al</code> sequentially. Because <code>(&quot;x&quot;, 3)</code> is more recent than <code>(&quot;x&quot;, 1)</code>, the lookup <code>lookup_opt &quot;x&quot; al</code> returns the <code>Some 3</code>, instead of <code>Some 1</code>.</p>
<pre><code class="language-ocaml">let al = insert &quot;x&quot; 3 (insert &quot;y&quot; 2 (insert &quot;x&quot; 1 []))
(* al is now [(&quot;x&quot;, 3), (&quot;y&quot;, 2), (&quot;x&quot;, 1)] *)

let _ = assert (lookup_opt &quot;z&quot; al = None)
let _ = assert (lookup_opt &quot;y&quot; al = Some 2)
let _ = assert (lookup_opt &quot;x&quot; al = Some 3)
</code></pre>
<p>Provide a recursive implementation for <code>lookup_opt</code>. Your code may not call any OCaml library functions.</p>
<blockquote>
<p><em>Hints:</em></p>
<ol>
<li><strong>On <code>option</code> types.</strong> A value of an <code>'a option</code> type can either be <code>None</code>, or <code>Some</code> of some value of type <code>'a</code>. Here is an example demonstrating the <code>option</code> type. If we want to divide integers without risking an exception, one solution is to use option types.
<pre><code class="language-ocaml">let safe_divide (x: int) (y: int) : int option = 
  if y = 0 then None else Some (x / y)
</code></pre>
</li>
<li><strong>On recursion.</strong> Recursion is simpler to use than loops in OCaml, and often better. You need to use <code>let rec</code> rather than <code>let</code> to declare a recursive function. Other than that, a function can call itself just as any other function. Here is a recursive function that computes the Hailstone sequence:
<pre><code class="language-ocaml">let rec hailstone n = 
  if n = 1 then
    print_string &quot;1 reached&quot;
  else if n mod 2 = 1 then
    hailstone (3*n+1)
  else
    hailstone (n / 2)
</code></pre>
</li>
<li><strong>On pattern-matching.</strong> As seen in the course slides, the primary way that you interact with values is by case analysis.
The syntax for case analysis is via <code>match .. with ..</code> which maps each possible case to the desired expression.
All values that are part of the case need to be assigned to variables if you want to use them in the expression. For instance, the following function uses pattern matching to sum the first two elements of a list:
<pre><code class="language-ocaml">let sum_of_first_2_elements (l: int list) : int =
  match l with
  | []          -&gt; 0
  | x :: []     -&gt; x
  | x :: y :: _ -&gt; x + y
</code></pre>
</li>
</ol>
</blockquote>
<hr />
<h2 id="problem-2-"><a class="header" href="#problem-2-">Problem 2 [★★]</a></h2>
<blockquote>
<p>Goal of this exercise: Practice pattern matching and functions as first-class objects.</p>
</blockquote>
<p>Patina\(^{arith}\) is a subset of Patina that only contains integer constants and binary expressions. Expressions will be represented in OCaml as abstract syntax trees as follows:</p>
<pre><code class="language-ocaml">type binop = Add | Sub | Mul | Div
type expr = Const of int
          | Binary of binop * expr * expr
</code></pre>
<p>Below are two Patina\(^{arith}\) expressions represented as <code>expr</code>:</p>
<ul>
<li><code>e1</code> represents the concrete expression &quot;0 + 2 * 3&quot;</li>
<li><code>e2</code> represents the concrete expression &quot;3 * 4 - 30 / 6&quot;</li>
</ul>
<pre><code class="language-ocaml">let e1 =
  Binary (
    Add,
    Const 0,
    Binary (Mul, Const 2, Const 3))

let e2 =
  Binary (
    Sub, 
    Binary (Mul, Const 3, Const 4),
    Binary (Div, Const 30, Const 6))
</code></pre>
<p>We provide you with a partially complete interpreter for Patina\(^{arith}\). The main interpreter function is <code>interpret</code>, which evaluates a Patina\(^{arith}\) expression to an OCaml integer.</p>
<pre><code class="language-ocaml">let rec interpret (e: expr) : int =
  match e with
  | Const n -&gt; n
  | Binary (op, e1, e2) -&gt; 
    (interpret_op op) (interpret e1) (interpret e2)

and interpret_op (op: binop) : int -&gt; int -&gt; int =
  match op with
  | _ -&gt; failwith &quot;Not yet implemented&quot; (* your code here *)
</code></pre>
<p>Here, <code>interpret</code> calls a helper function, <code>interpret_op</code>, which evaluates binary integer operators (<code>binop</code>) to their interpretations as OCaml functions (<code>int -&gt; int -&gt; int</code>). The binary operators have the usual interpretations, and <code>Div</code> should be interpreted as integer division. For instance, <code>interpret e1</code> should return <code>6</code>, and <code>interpret e2</code> should return <code>7</code>. </p>
<p>Complete the definition for <code>interpret_op</code>. You don't need to handle division by zero, since the test cases won't contain input expressions that cause division by zero errors.</p>
<blockquote>
<p><em>Hint:</em> You are likely to find <a href="https://cs3110.github.io/textbook/chapters/basics/functions.html?highlight=anonymous#anonymous-functions">anonymous functions</a> helpful here.</p>
<p>As an example, the following variable <code>three_anonymous</code> is a tuple of 3 anonymous functions so you can see how they're created:</p>
<pre><code class="language-ocaml">let three_anonymous =
  ( (fun x -&gt; if x then 3 else 6),
    (fun x -&gt; fun y -&gt; x ^ y),
    (fun (a,b,c) -&gt; if a &gt; b then a-b else c) )
</code></pre>
<p>The first takes a <code>bool</code> to an <code>int</code>, the second concatenates two <code>string</code>s, and the third compares integers. You will notice that the second is an anonymous function returning an anonymous function, whereas the third takes all its arguments as a triple. The former format is called &quot;curried&quot; and the latter &quot;uncurried&quot;. Be careful to use the right one.</p>
</blockquote>
<hr />
<h2 id="problem-3-"><a class="header" href="#problem-3-">Problem 3 [★★★★]</a></h2>
<blockquote>
<p>Goal of this exercise: Practice pattern matching and simulating &quot;state changes&quot; in a functional way.</p>
</blockquote>
<p>Now let us extend Patina\(^{arith}\) into Patina\(^{let}\), which additionally supports variable bindings and sequences:</p>
<pre><code class="language-ocaml">type binop = Add | Sub | Mul | Div
type expr = Const of int
          | Binary of binop * expr * expr
          | Id of string             (* new *)
          | Let of string * expr     (* new *)
          | Seq of expr list         (* new *)
</code></pre>
<p>A <code>Let</code> expression is a <code>string * expr</code> pair, where the value of the <code>expr</code> will be bound to the <code>string</code> name. The name will available in subsequent expressions in the parent <code>Seq</code> expression. Any binding created in the <code>expr</code> will not be inherited. For example, the following expression</p>
<pre><code class="language-ocaml">Seq [
  Let (&quot;x&quot;, 0);
  (* Current environment: x |-&gt; 0 *)
  
  Let (&quot;y&quot;, Let (&quot;x&quot;, 1));
  (* Current environment: y |-&gt; 0, x |-&gt; 0 *)
  x
]
</code></pre>
<p>evaluates to 0, because the second binding of <code>y</code> is created in the right-hand side of binding of <code>x</code>, hence is ignored.</p>
<p>The evaluation rules for the newly added constructs are as follows:</p>
<ul>
<li>A <code>Let</code> expression evaluates to <code>0</code>.</li>
<li>A <code>Seq</code> expression evaluates to the value of the last expression in the sequence.</li>
<li>An <code>Id</code> expression evaluates the value associated with the identifier string.</li>
</ul>
<p>In the example below,</p>
<ul>
<li><code>e1</code> represents the concrete Patina expression <code>{ let x: int = 2; x * 3 }</code>,</li>
<li><code>e2</code> represents the concrete Patina expression 
<code> { let x: int = -1; { let x: int = 2; x }; x }</code></li>
</ul>
<pre><code class="language-ocaml">let e1 = 
  Seq [
    Let (&quot;x&quot;, Const 2);
    Binary (Mul, Id &quot;x&quot;, Const 3)
  ]

let e2 =
  Seq [
    Let (&quot;x&quot;, Const (-1));
    Seq [ Let (&quot;x&quot;, Const 2); Id &quot;x&quot; ];
    Id &quot;x&quot;
  ]

let _ = assert (interpret e1 = 6)
let _ = assert (interpret e2 = (-1))
</code></pre>
<p><code>e1</code> evaluates to <code>6</code>, because the let-expression binds <code>&quot;x&quot;</code> to <code>Const 2</code>, and the binary expression <code>Binary (Mul, Id &quot;x&quot;, Const 3)</code> evaluates to <code>6</code> when <code>Id &quot;x&quot;</code> is replaced with <code>Const 2</code>.</p>
<p><code>e2</code> evaluates to <code>-1</code>, because the last <code>&quot;x&quot;</code> refers to the variable bound in the outer sequence.</p>
<p>Extend your interpreter in Problem 2 to support the new language constructs. Your <code>interpret</code> will have the following type:</p>
<pre><code class="language-ocaml">let rec interpret (e: expr) : int = 
  failwith &quot;Not yet implemented&quot; (* your code here *)
</code></pre>
<p>You may assume that the test cases won't contain semantic or runtime errors, such as reference to unbound variables, or empty sequences.</p>
<blockquote>
<p><em>Hints:</em> </p>
<ol>
<li>
<p>You may want to use some kind of environment (recall what you did in Problem 1) to keep track of the values of variables that are in scope:</p>
<pre><code class="language-ocaml">type environment = (string * int) list
</code></pre>
</li>
<li>
<p><code>interpret</code> itself can be non-recursive, and can call another helper function that actually evaluates the expressions recursively. The helper function may look like:</p>
<pre><code class="language-ocaml">let rec interpret' (e: expr) (env: environment) : (environment * int) =
   match e with
   ...
</code></pre>
<p>Compared to <code>interpret</code>, the function <code>interpret'</code> additionally takes in an <code>environment</code>, and additionally returns an <code>environment</code> augmented by <code>Let</code> expressions <sup class="footnote-reference"><a href="#1">1</a></sup>.</p>
</li>
<li>
<p>Be very careful how <code>Seq</code> and your environment interact. If you are unsure, the <a href="assignments/../overview/unit.html#variable-declaration">Variable Declaration</a> section in the Patina language overview contains more examples and explanations.</p>
</li>
</ol>
</blockquote>
<hr />
<h2 id="bonus-problem-4-"><a class="header" href="#bonus-problem-4-"><em>(Bonus)</em> Problem 4 [★★★]</a></h2>
<p>Extend your interpreter to support Patina\(^{ref}\), which further supports assignments and while loops:</p>
<pre><code class="language-ocaml">type binop = Add | Sub | Mul | Div
type expr = Const of int
          | Binary of binop * expr * expr
          | Id of string
          | Let of string * expr
          | Seq of expr list
          | Assign of string * expr    (* new *)
          | While of expr * expr       (* new *)
</code></pre>
<p>Both <code>Assign</code> and <code>While</code> evaluate to <code>0</code>. A <code>While</code> expression is an <code>expr * expr</code> pair, where the first item of the pair is the condition, and the second item is the loop body.</p>
<p>Because we don't model booleans here (for simplicity), simply treat the zero value as <code>false</code>, and non-zero values as <code>true</code>.</p>
<p>For more information about the semantics of assignment and while expressions, refer to the relevant parts in the section on <a href="assignments/../overview/unit.html">Unit Expressions</a> in the Patina language overview.</p>
<blockquote>
<p><em>Hint:</em> You may want to use <a href="https://cs3110.github.io/textbook/chapters/mut/refs.html"><code>ref</code> cells</a> for your environment:</p>
<pre><code class="language-ocaml">type environment = (string * int ref) list
</code></pre>
</blockquote>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>This helper function is an example of what's called a <a href="http://learnyouahaskell.com/for-a-few-monads-more#state">state monad</a>, which is a functional way of simulating &quot;state changes&quot; without using mutable variables. (The linked article is for people learning a different functional language called Haskell, but the syntax involved in that particular discussion is quite similar to OCaml's syntax.) </p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cs160-assignment-2-lexing-and-parsing"><a class="header" href="#cs160-assignment-2-lexing-and-parsing">CS160 Assignment 2: Lexing and Parsing</a></h1>
<p><strong>Assignment due: Friday, October 29 11:59PM</strong></p>
<h2 id="changelog-2"><a class="header" href="#changelog-2">Changelog</a></h2>
<ol>
<li>The regular expression for <code>ID</code> should match underscores.</li>
<li>Due date has been extended to Friday.</li>
</ol>
<h2 id="introduction-2"><a class="header" href="#introduction-2">Introduction</a></h2>
<p>In this assignment, you will first write some toy programs in the Patina language to get more familiar with the language's syntax. Then, you will build a lexer and a parser to parse well-formed Patina programs into abstract syntax trees.</p>
<h2 id="instructions"><a class="header" href="#instructions">Instructions</a></h2>
<ol>
<li>
<p>Download the starter code <a href="https://github.com/fredfeng/CS160/tree/main/assignments/as2">here</a>.</p>
</li>
<li>
<p>Unlike Assignment 1, the starter code is no longer individual files, but a self-contained <code>dune</code> project. You will need to install <code>dune</code> through <code>opam</code>:</p>
<pre><code> opam install dune
</code></pre>
<p>There is <a href="https://junrui-liu.github.io/patina/setup/setup.html">guide</a> on how to install <code>opam</code> on your machine or CSIL. If you encounter any difficulty installing <code>opam</code> or <code>dune</code>, please let us know on Slack.</p>
</li>
<li>
<p>The only files you need to modify are <code>scanner.mll</code> and <code>parser.mly</code>. </p>
</li>
<li>
<p>A driver program (<code>patina.ml</code>) is provided to help you test your lexer/parser. It requires <code>ppx_deriving.show</code> for pretty printing, which you can install with <code>opam install ppx_deriving</code>. Once you have that, you can run the driver on a Patina source file with</p>
<pre><code> dune exec ./patina.exe -- &lt;filename&gt;
</code></pre>
</li>
</ol>
<h2 id="submission-and-grading-1"><a class="header" href="#submission-and-grading-1">Submission and Grading</a></h2>
<p>Submit your <code>scanner.mll</code> and <code>parser.mly</code> to <a href="https://www.gradescope.com/courses/322641">gradescope</a>.</p>
<p>Please make sure that your code compiles before submitting them.</p>
<p>There are 21 tests in total, 16 of which are public. You can find the public tests <a href="https://github.com/fredfeng/CS160/tree/main/assignments/as2/tests">here</a>.</p>
<h2 id="part-1"><a class="header" href="#part-1">Part 1</a></h2>
<p>You will write some simple programs in the Patina language. We'll provide you with a <a href="https://github.com/fredfeng/CS160/tree/main/assignments/as2/interpreter">prototype interpreter</a> for you to validate your programs. Be aware that the prototype is quite crappy; by the end of this course will have a compiler that's much better than ours. Use <code>patina-darwin</code> if your machine uses macOS, and <code>patina-linux</code> if your machine uses Linux (including CSIL). Run it with <code>./patina-&lt;your-os&gt; -i &lt;patina-source-file&gt;</code>.</p>
<p>For each of these, we recommend looking at the <a href="assignments/../ref.html">syntax reference</a> of Patina, as well as the <a href="assignments/../overview/overview.html">overview</a> of Patina in the first section of the page. They should contain all the information that is necessary to complete the assignments. For anything that's unclear after that, ask on Slack!</p>
<h3 id="program-1"><a class="header" href="#program-1">Program 1</a></h3>
<p>Write a simple function to practice the oddities of Patina syntax. This function should take an int as argument, create an array with length equal to the integer, fill it with 7s, and then return it. The main function should call this function with 3 as its input and print out the 2nd value in the result.</p>
<h3 id="program-2"><a class="header" href="#program-2">Program 2</a></h3>
<p>Let's follow up on the section - write a function that takes in an integer and returns whether or not the integer is a perfect number. You can do so by creating a list of all the factors of the input integer, and then sums them together to check whether a number is perfect or not, returning <code>true</code> if it is and <code>false</code> otherwise.</p>
<p>In your <code>main</code> function, use a while loop to print out perfect numbers up to 1000, each on a new line. For example, if your source file is named <code>perfect.pt</code>, then running <code>./patina-&lt;your-os&gt; -i perfect.pt</code> should output</p>
<pre><code>6
28
496
</code></pre>
<h2 id="part-2"><a class="header" href="#part-2">Part 2</a></h2>
<p>The first step of a compiler is splitting the string of the whole code into pieces which represent all of the important parts. Since Patina has no syntax for comments, this should be straightforward.</p>
<p>Ocaml has the very useful tool for doing lexing of <code>ocamllex</code>, which takes a definition of a mapping from token strings to tokens, and produces an automaton that can actually do the lexing. This takes advantage of the insight you've learned in class about how simple enough languages can be parsed with simple automata.</p>
<p>Each of the lines of code will look something like:</p>
<pre><code>  | '/'  { DIV }         
</code></pre>
<p>Each of these tokens is atomic for the purpose of parsing - it can't be divided further without losing some utility. For example, you don't want to make each digit in an integer a separate token, because you'd have to put them all together when parsing any case where they're used. On the other hand, you wouldn't want to count &quot;(2&quot; as a token, because that parenthesis is going to work just as any other parenthesis in the problem.</p>
<p>Fill out the rows of your template <code>scanner.mll</code> file to write a lexer for Patina's full syntax.</p>
<h2 id="part-3-parser"><a class="header" href="#part-3-parser">Part 3: Parser</a></h2>
<p>Parsing is the central work of this assignment, and the purpose of good lexing is to make parsing easier.</p>
<p><code>ocamlyacc</code> is a tool which automatically generates a parser for a language if you define how it works. You will use it to parse textual file containing Patina programs into their abstract syntax tree representation.</p>
<p>Each line of the parser should be inside of a block defining a non-terminal or terminal symbol, and should include both the symbols that make it up on the left, as well as OCaml code (using the constructors of the AST) which represents the value on the right. This value is <em>not</em> the result of interpretation of the code, so no addition or other calculation should be done.</p>
<p>For example, to say that an expression formed by two sub-expressions separated by the <code>DIV</code> token, we write</p>
<pre><code>expr:
    ...
    | expr DIV expr      { Binary(Div, $1,$3) }
</code></pre>
<p>We have defined an abstract syntax tree (AST) type for you in <code>ast.ml</code>, but it's up to you do define the intermediate nodes of parsing. You can use the patina concrete reference not only as a reference of how Patina code looks, but also as hints for what parsing structure to use.</p>
<p>Modify the template <code>parser.mly</code> file to write a parser for Patina's full syntax. Specifically, you will need to add three kinds of stuff:</p>
<ol>
<li>Since the parser is connected to the lexer your wrote for Part 2, you need to declare in the parser file the tokens you defined in the lexer:
<pre><code>%token // TODO: Your tokens here
</code></pre>
</li>
<li>Define your grammar rules:
<pre><code>// TODO: Your rules here E.g.
</code></pre>
</li>
<li>Your grammar will likely be ambiguous (i.e. there will be shift/reduce or even reduce/reduce conflicts). You can resolve a lot of ambiguities by simply specifying the <a href="https://ocaml.org/manual/lexyacc.html#ss:ocamlyacc-declarations">precedence and associativity</a> of the elements in your grammar:
<pre><code>// TODO: Your associativity rules here
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cs160-assignment-3-type-checking"><a class="header" href="#cs160-assignment-3-type-checking">CS160 Assignment 3: Type Checking</a></h1>
<p><strong>Assignment due: Monday, November 15 11:59PM</strong></p>
<p>In this assignment, you will implement a type checker for your Patina compiler.</p>
<h2 id="instructions-1"><a class="header" href="#instructions-1">Instructions</a></h2>
<ol>
<li>Download the starter code <a href="https://github.com/fredfeng/CS160/blob/main/assignments/as3/">here</a>.</li>
<li>Make sure you have installed <code>dune</code> and <code>ppx_deriving</code> via <code>opam</code>, as required in AS2. You don't need to install anything new for this assignment. </li>
<li>Replace <code>scanner.mll</code> and <code>parser.mly</code> with your own implementation from AS2.</li>
<li>Complete the type checker in <code>typecheck.ml</code> (described in greater details later).</li>
<li>As in the previous assignment, we provide you with a driver program (<code>patina.ml</code>) that takes in Patina source files and invokes your parser and type checker on them. Run the driver program with
<pre><code>dune exec ./patina.exe -- &lt;patina-source-file&gt; 
</code></pre>
</li>
</ol>
<h2 id="submission-and-grading-2"><a class="header" href="#submission-and-grading-2">Submission and Grading</a></h2>
<p>We will update this section once the autograder is ready.</p>
<h2 id="what-you-need-to-implement"><a class="header" href="#what-you-need-to-implement">What You Need to Implement</a></h2>
<blockquote>
<p>If you are feeling adventurous, you can start with an empty <code>typecheck.ml</code> file and build your type checker from scratch. The only requirement is that the file should export a function called <code>check_prog</code> with the following signature:</p>
<pre><code class="language-ocaml">val check_prog : Ast.prog -&gt; unit
</code></pre>
<p>This function takes in an <code>Ast.prog</code>. It returns unit if there's no type error, and raises <code>Error.TypeError</code> otherwise.</p>
</blockquote>
<p>You will implement the typing rules described in the <a href="https://junrui-liu.github.io/patina/ref.html#typing-rules">reference manual</a>, as well as a few more semantic checks.</p>
<p>The <code>typecheck.ml</code> file contains a skeleton of the type checking algorithm. On a high level, it is quite similar to the <code>interpret'</code> function you wrote in AS1:</p>
<ul>
<li>The main type checking function, <code>check</code>, takes in an expression and some environment, and outputs a pair consisting of a new environment and some <code>result</code>.</li>
<li>Previously, the <code>result</code> type was <code>int</code>, because your interpreter was evaluating the input expression to an integer. Now the <code>result</code> type is <code>Ast.typ</code> (which can be either <code>TUnit</code>, <code>TBool</code>, <code>TInt</code>, or <code>TArr</code>), because the type checker computes the type of the input expression (if the expression is well-typed).</li>
<li>Previously, the <code>environment</code> type was <code>(string * int) list</code>, which maps identifiers to their integer values<sup class="footnote-reference"><a href="#1">1</a></sup>. Now the environment is called <code>tenv</code>, which stands for <strong>t</strong>yping <strong>env</strong>ironment. This is the \(\Gamma\) you have encountered in the typing rules, which maps identifiers to their declared types. The <code>check</code> function also takes in a <strong>f</strong>unction <strong>env</strong>ironment, which is the \(\Delta\) in the typing rules.</li>
</ul>
<p>The structure of <code>check</code> is also quite similar to <code>interpret'</code>. It traverses the AST in a post-order/bottom-up manner, by pattern-matching on the input expression, recursively type-checking the sub-expressions (if any), and aggregating the types of the sub-expressions. You can see a concrete example in the partially written cases we've provided. For example, in the case of unary <code>Not</code> expressions,</p>
<pre><code class="language-ocaml">| Unary (Not, e) -&gt;
    let te = type_of e in
    expect e TBool te;
    return TBool
</code></pre>
<p>we first recursively type check the sub-expressions <code>e</code>. Then we assert that <code>e</code> have type <code>TBool</code>. Finally, we return the type of the overall unary expression, which is also <code>TBool</code>.</p>
<p>However, it is not always the case that an expression is well-typed. What should <code>check</code> return in those cases? Clearly, we can't return a type as we normally would, because that would mean that the ill-typed expression <em>has</em> a valid type. Instead, the way we handle ill-typed expressions in this assignment is through exceptions. You have probably encountered exceptions in other languages. In OCaml, to raise an exception <code>exn</code>, we simply say <code>raise exn</code>. To handle exception <code>exn</code> that might arise during the evaluation of an expression <code>e</code>, we write</p>
<pre><code class="language-ocaml">try
  e
with
| exn -&gt; (* exception handling code *)
</code></pre>
<p>If your type checker encounters a type error, it should raise a <code>TypeError</code>, which is defined in <code>error.ml</code>. <strong>However, you don't need to raise exceptions explicitly using <code>raise</code> (and we recommend against doing that).</strong> Instead, use the helper functions <code>error.ml</code>, who will raise the appropriate exceptions on your behalf.</p>
<p>Fill in the missing parts that are marked with <code>hole ()</code> in <code>typecheck.ml</code>.</p>
<p>In addition to the typing rules described in the reference manual, your type checker should also perform a few other semantic checks. For example, a program should only have one <code>main</code> function, which takes no argument and returns a unit. You can get some hints as to what kinds of semantic checks need to be performed, by looking at the helper functions in <code>error.ml</code>.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>You can think of the environment in AS1 as a lazy substitution table.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cs160-assignment-4-code-generation"><a class="header" href="#cs160-assignment-4-code-generation">CS160 Assignment 4: Code Generation</a></h1>
<p><strong>Assignment due: Monday, November 29 11:59PM</strong></p>
<p>Your compiler will generate x86 assembly code for Patina programs.</p>
<h2 id="submission-and-grading-3"><a class="header" href="#submission-and-grading-3">Submission and Grading</a></h2>
<p>TBF</p>
<h2 id="introduction-3"><a class="header" href="#introduction-3">Introduction</a></h2>
<p>For this assignment, you will be tackling the most central part of a compiler: the generation of code of a lower level language. In this case, we will be using x86 as the target language. See the <a href="assignments/as4.html#resources">Resources</a> section</p>
<p>This would normally be far more difficult than each of the other individual stages of the compiler. However, we have introduced a number of simplifications to make it doable.</p>
<ol>
<li>
<p>Function calls are disallowed, and any functions besides main. In essence, the patina files to be compiled will represent a simple script. (Functions will be included in <a href="assignments/as4.html#bonus-part-1---functions">bonus part #1</a>.)</p>
</li>
<li>
<p>Arrays are no longer included in the language specification. This allows all data to be stored on the stack as supposed to on the heap. (Arrays will be included in <a href="assignments/as4.html#bonus-part-2---arrays">bonus part #2</a>.)</p>
</li>
<li>
<p>This matters for performance but not to correctness, no register allocation algorithm needs to be written. All data will be stored inside a single frame of the stack.</p>
</li>
</ol>
<h2 id="overview-of-approach"><a class="header" href="#overview-of-approach">Overview of approach</a></h2>
<p>However, this still leaves a fair amount of complexity. For example, the following function calculating fibonacci numbers is still allowed.</p>
<pre><code class="language-rust no_run noplayground">fn main() -&gt; unit {
	let fibn : int = 10;
	let firstval : int = 1;
	let secondval : int = 1;
	if (fibn &lt; 0) then {
		let res : int = 0/0
	} else {
   	while (fibn &gt; 0){
   		let sum : int = firstval + secondval;
   		firstval = secondval;
   		secondval = sum;
   		fibn = fibn - 1
	};
	let res : int = secondval
   }
}
</code></pre>
<p>As you can see, this still contains the challenges for implementation of</p>
<ol>
<li>jumps required for while loops and if expressions</li>
<li>binop expressions which when compiled require multiple lines of assembly.</li>
</ol>
<p>For the former, you will be adding labels into the assembly to allow appropriate jumps. For example, the expression <code>if false then {2} else {1} + 1</code> should be translated into something equivalent to the following (ignore the binop compilation there for now).</p>
<pre><code>cmp $1, $0
je L1
mov $1, %rax
jmp L2
L1:
mov $2, %rax
L2:
add $1, %rax
</code></pre>
<p>For the latter, you will be reading variables from the stack into some fixed registers, pushing them onto the stack temporarily to allow for arbitrary depth arithmetic trees, and then writing them back there. For example, the expression <code>x = x * 4</code> should be translated into something equivalent to the following (which is inefficient, but you only need correctness for now.)</p>
<pre><code>mov 16(%rbp), %rax
push %rax
mov $4, %rax
mov %rax, %rbx
pop %rax,
add %rbx, %rax
mov %rax, 16(%rbp)
</code></pre>
<h2 id="what-you-need-to-implement-1"><a class="header" href="#what-you-need-to-implement-1">What you need to implement</a></h2>
<p>In each of these cases, you can test your code (download the files from the github repository) by running</p>
<p><code>./patinac {yourfile.pt}; ./prog</code>.</p>
<p>The easiest way to test is likely to be testing purely on expressions. In order to do this you must designate expr as a start symbol in your parser, just as prog is already.</p>
<p>Inside patinac, you can delete or keep the -e flag to determine whether the file is being parsed as a program with a single function in it or as just an expression, respectively.</p>
<h3 id="mandatory-part---loops-conditionals-and-variables"><a class="header" href="#mandatory-part---loops-conditionals-and-variables">Mandatory Part - Loops, Conditionals, and Variables</a></h3>
<p>Fill in the holes in the provided code, so that the <code>compile</code> function correctly converts an AST from the following subset of Patina to x86 assembly.</p>
<pre><code class="language-ocaml">type expr =
   | Const of const
   | Id of string
   | Let of string * typ * expr
   | Assign of string * expr
   | Unary of unop * expr
   | Binary of binop * expr * expr
   | Ite of expr * expr * expr
   | Seq of expr list
   | While of expr * expr
</code></pre>
<h3 id="bonus-part-1---functions"><a class="header" href="#bonus-part-1---functions">Bonus Part 1 - Functions</a></h3>
<p>TBF</p>
<h3 id="bonus-part-2---arrays"><a class="header" href="#bonus-part-2---arrays">Bonus Part 2 - Arrays</a></h3>
<p>TBF</p>
<h2 id="resources"><a class="header" href="#resources">Resources</a></h2>
<h3 id="x86-assembly"><a class="header" href="#x86-assembly">x86 Assembly</a></h3>
<ol>
<li><a href="https://flint.cs.yale.edu/cs421/papers/x86-asm/asm.html">Quick Start Guide</a></li>
<li><a href="https://cs.brown.edu/courses/cs033/docs/guides/x64_cheatsheet.pdf">Cheat sheet #1</a></li>
<li><a href="http://www.cs.cmu.edu/afs/cs/academic/class/15213-s20/www/recitations/x86-cheat-sheet.pdf">Cheat sheet #2</a></li>
</ol>
<h3 id="x86-calling-convention-cdecl"><a class="header" href="#x86-calling-convention-cdecl">x86 Calling Convention (<code>cdecl</code>)</a></h3>
<ol>
<li><a href="https://en.wikipedia.org/wiki/X86_calling_conventions">Wikipedia page</a> on x86 calling conventions</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cs160-assignment-5-optimizations"><a class="header" href="#cs160-assignment-5-optimizations">CS160 Assignment 5: Optimizations</a></h2>
<p><strong>Assignment due: TBD</strong></p>
<h2 id="submission-and-grading-4"><a class="header" href="#submission-and-grading-4">Submission and Grading</a></h2>
<p>TBF</p>
<h2 id="what-you-need-to-implement-2"><a class="header" href="#what-you-need-to-implement-2">What you need to implement</a></h2>
<p>In this assignment, you will implement the optimization phase for your compiler. Optimizations are commonly performed on <a href="https://en.wikipedia.org/wiki/Intermediate_representation">intermediate representations</a>. However, for simplicity you will directly optimize on the following subset of Patina AST, which excludes variable mutation, arrays, and while loops:</p>
<pre><code class="language-ocaml">type expr =
  | Const of const
  | Id of string
  | Let of string * typ * expr
  | Unary of unop * expr
  | Binary of binop * expr * expr
  | Ite of expr * expr * expr
  | Seq of expr list
  | Call of string * expr list
</code></pre>
<p>On minimum, you should implement constant folding and propagation:</p>
<ol>
<li>Constant folding partially evaluates an expression as much as it can. For example, the nested binary expression <code>100 * 100 * 100</code> will be replaced with a single constant, <code>1000000</code>.</li>
<li>Constant propagation replaces references to constant variables with their actual values. For instance, the sequence <code>{ let x: int = 1; print_int(x) }</code> will be transformed into <code>{ let x: int = 1; print_int(1) }</code>.</li>
</ol>
<p>Fill in the body of function <code>fold_constant</code> in <code>optimize.ml</code>. As always, you will likely need some kind of environment (to do constant propagation). Think about what kind of environment might be good. Then, replace <code>bottom</code> with a type of your choice on the following line in <code>optimize.ml</code>:</p>
<pre><code class="language-ocaml">type env = (string * bottom) list
</code></pre>
<p>and perform <code>fold_constant</code> using this environment.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
    </body>
</html>
